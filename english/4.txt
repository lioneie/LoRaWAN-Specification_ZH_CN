
4 MAC Message Formats
All LoRa uplink and downlink messages carry a PHY payload (Payload) starting with a single-octet MAC header (MHDR), followed by a MAC payload (MACPayload), and ending with a 4-octet message integrity code (MIC).
Radio PHY layer:

1 Maximum payload size is detailed in the Chapter 6.
2 For Join-Accept frame, the MIC field is encrypted with the payload and is not a separate field


4.1 MAC Layer (PHYPayload)
The maximum length (M) of the MACPayload field is region specific and is specified in Chapter 6.

4.2 MAC Header (MHDR field)
The MAC header specifies the message type (MType) and according to which major version (Major) of the frame format of the LoRaWAN layer specification the frame has been encoded.

4.2.1 Message type (MType bit field)
The LoRaWAN distinguishes between 8 different MAC message types: Join-request, Rejoin-request, Join-accept, unconfirmed data up/down, and confirmed data up/down and proprietary protocol messages.

4.2.1.1 Join-request and join-accept messages
The join-request, Rejoin-request and join-accept messages are used by the over-the-air activation procedure described in Chapter 6.2 and for roaming purposes.


4.2.1.2 Data messages
Data messages are used to transfer both MAC commands and application data, which can be combined together in a single message. A confirmed-data message MUST be acknowledged by the receiver, whereas an unconfirmed-data message does not require an acknowledgment. Proprietary messages can be used to implement non-standard message formats that are not interoperable with standard messages but must only be used among devices that have a common understanding of the proprietary extensions. When an end-device or a Network Server receives an unknown proprietary message, it SHALL silently drop it.

Message integrity is ensured in different ways for different message types and is described per message type below.


1 A detailed timing diagram of the acknowledge mechanism is given in Section 19.

4.2.2 Major version of data message (Major bit field)

Note: The Major version specifies the format of the messages exchanged in the join procedure (see Chapter 6.2) and the first four bytes of the MAC Payload as described in Chapter 4. For each major version, end-devices may implement different minor versions of the frame format. The minor version used by an end-device must be made known to the Network Server beforehand using out of band messages (e.g., as part of the device personalization information). When a device or a Network Server receives a frame carrying an unknown or unsupported version of LoRaWAN, it SHALL silently drop it.

4.3 MAC Payload of Data Messages (MACPayload)

The MAC payload of the data messages, contains a frame header (FHDR) followed by an optional port field (FPort) and an optional frame payload field (FRMPayload).

A frame with a valid FHDR, no Fopts (FoptsLen = 0), no Fport and no FRMPayload is a valid frame.

4.3.1 Frame header (FHDR)

The FHDR contains the short device address of the end-device (DevAddr), a frame control octet (FCtrl), a 2-octets frame counter (FCnt), and up to 15 octets of frame options (FOpts) used to transport MAC commands. If present, the FOpts field shall be encrypted using the NwkSEncKey as described in section 4.3.1.6.

For downlink frames the FCtrl content of the frame header is:

4.3.1.1 Adaptive data rate control in frame header (ADR, ADRACKReq in FCtrl)

LoRa network allows the end-devices to individually use any of the possible data rates and Tx power. This feature is used by the LoRaWAN to adapt and optimize the data rate and Tx power of static end-devices. This is referred to as Adaptive Data Rate (ADR) and when this is enabled the network will be optimized to use the fastest data rate possible.

Adaptive Data Rate control may not be possible when the radio channel attenuation changes fast and constantly. When the Network Server is unable to control the data rate of a device, the deviceâ€™s application layer should control it. It is recommended to use a variety of different data rates in this case. The application layer SHOULD always try to minimize the aggregated air time used given the network conditions.

If the uplink ADR bit is set, the network will control the data rate and Tx power of the end-device through the appropriate MAC commands. If the ADR bit is not set, the network will not attempt to control the data rate nor the transmit power of the end-device regardless of the received signal quality. The network MAY still send commands to change the Channel mask or the frame repetition parameters.

When the downlink ADR bit is set, it informs the end-device that the Network Server is in a position to send ADR commands. The device MAY set/unset the uplink ADR bit.

When the downlink ADR bit is unset, it signals the end-device that due to rapid changes of the radio channel, the network temporarily cannot estimate the best data rate. In that case the device has the choice to either

? unset the ADR uplink bit, and control its uplink data rate following its own strategy. This SHOULD be the typical strategy for a mobile end-device.
? Ignore it (keep the uplink ADR bit set) and apply the normal data rate decay in the absence of ADR downlink commands. This SHOULD be the typical strategy for a stationary end-device.

The ADR bit may be set and unset by the end-device or the Network on demand. However, whenever possible, the ADR scheme SHOULD be enabled to increase the battery life of the end-device and maximize the network capacity.

Note: Even mobile end-devices are actually immobile most of the time. So depending on its state of mobility, an end-device can request the network to optimize its data rate using the ADR uplink bit.

Default Tx Power is the maximum transmission power allowed for the device considering device capabilities and regional regulatory constraints. Device shall use this power level, until the network asks for less, through the LinkADRReq MAC command.

If an end-device’s data rate is optimized by the network to use a data rate higher than its default data rate, or a TXPower lower than its default TXPower, it periodically needs to validate that the network still receives the uplink frames. Each time the uplink frame counter is incremented (for each new uplink, repeated transmissions do not increase the counter), the device increments an ADR_ACK_CNT counter. After ADR_ACK_LIMIT uplinks(ADR_ACK_CNT >= ADR_ACK_LIMIT) without any downlink response, it sets the ADR acknowledgment request bit (ADRACKReq). The network is required to respond with a downlink frame within the next ADR_ACK_DELAY frames, any received downlink frame following an uplink frame resets the ADR_ACK_CNT counter. The downlink ACK bit does not need to be set as any response during the receive slot of the end-device indicates that the gateway has still received the uplinks from this device. If no reply is received within the next ADR_ACK_DELAY uplinks (i.e., after a total of ADR_ACK_LIMIT + ADR_ACK_DELAY), the end-device MUST try to regain connectivity by first stepping up the transmit power to default power if possible then switching to the next lower data rate that provides a longer radio range. The end-device MUST further lower its data rate step by step every time ADR_ACK_DELAY is reached. Once the device has reached the lowest data rate, it MUST re-enable all default uplink frequency channels.

The ADRACKReq SHALL not be set if the device uses its default data rate and transmit power because in that case no action can be taken to improve the link range.

Note: Not requesting an immediate response to an ADR acknowledgement request provides flexibility to the network to optimally schedule its downlinks.

Note: In uplink transmissions the ADRACKReq bit is set if ADR_ACK_CNT >= ADR_ACK_LIMIT and the current data-rate is greater than the device defined minimum data rate or its transmit power is lower than the default, or the current channel mask only uses a subset of all the default channels. It is cleared in other conditions.

The following table provides an example of data rate back-off sequence assuming ADR_ACK_LIMIT and ADR_ACK_DELAY constants are both equal to 32.

4.3.1.2 Message acknowledge bit and acknowledgement procedure (ACK in FCtrl)

When receiving a confirmed data message, the receiver SHALL respond with a data frame that has the acknowledgment bit (ACK) set. If the sender is an end-device, the network will try to send the acknowledgement using one of the receive windows opened by the end-device after the send operation. If the sender is a gateway, the end-device transmits an
acknowledgment at its own discretion (see note below).

An acknowledgement is only sent in response to the latest message received and it is never retransmitted.

Note: To allow the end-devices to be as simple as possible and have as few states as possible it may transmit an explicit (possibly empty) acknowledgement data message immediately after the reception of a data message requiring a confirmation. Alternatively the end-device may defer the transmission of an acknowledgement to piggyback it with its next data message.

4.3.1.3 Retransmission procedure
Downlink frames:
A downlink “confirmed” or “unconfirmed” frame SHALL not be retransmitted using the same frame counter value. In the case of a “confirmed” downlink, if the acknowledge is not received, the application server is notified and may decide to retransmit a new “confirmed” frame.

Uplink frames:
Uplink “confirmed” & “unconfirmed” frames are transmitted “NbTrans” times (see 5.3) except if a valid downlink is received following one of the transmissions. The “NbTrans” parameter can be used by the network manager to control the redundancy of the node uplinks to obtain a given Quality of Service. The end-device SHALL perform frequency hopping as usual
between repeated transmissions, It SHALL wait after each repetition until the receive
windows have expired. The delay between the retransmissions is at the discretion of the
end-device and MAY be different for each end-device.

The device SHALL stop any further retransmission of an uplink “confirmed” frame if a corresponding downlink acknowledgement frame is received

Class B&C devices SHALL stop any further retransmission of an uplink “unconfirmed” frame whenever a valid unicast downlink message is received during the RX1 slot window.

Class A devices SHALL stop any further retransmission of an uplink “unconfirmed” frame whenever a valid downlink message is received during the RX1 or the RX2 slot window.

If the network receives more than NbTrans transmissions of the same uplink frame, this may be an indication of a replay attack or a malfunctioning device, and therefore the network SHALL not process the extra frames.

NOTE: The network detecting a replay attack may take additional measures, such as reducing the NbTrans parameter to 1, or discarding uplink frames that are received over a channel that was already used by an earlier transmission of the same frame, or by some other unspecified mechanism

4.3.1.4 Frame pending bit (FPending in FCtrl, downlink only)

The frame pending bit (FPending) is only used in downlink communication, indicating that the network has more data pending to be sent and therefore asking the end-device to open another receive window as soon as possible by sending another uplink message. The exact use of FPending bit is described in Chapter 19.3.

4.3.1.5 Frame counter (FCnt)

Each end-device has three frame counters to keep track of the number of data frames sent uplink to the Network Server (FCntUp), and sent downlink from the Network Server to the device (FCntDown).

In the downlink direction two different frame counter scheme exists; a single counter scheme in which all ports share the same downlink frame counter FCntDown when the device operates as a LoRaWAN1.0 device, and a two-counter scheme in which a separate NFCntDown is used for MAC communication on port 0 and when the FPort field is missing, and another AFCntDown is used for all other ports when the device operates as a LoRaWAN1.1 device.

In the two counters scheme the NFCntDown is managed by the Network Server, whereas the AFCntDown is managed by the application server.

Note: LoRaWAN v1.0 and earlier support only one FCntDown counter(shared across all ports) and the Network Server must take care to support this scheme for devices prior to LoRaWAN v1.1.

Whenever an OTAA device successfully processes a Join-accept message, the frame counters on the end-device (FCntUp) and the frame counters on the network side(NFCntDown & AFCntDown) for that end-device are reset to 0.

ABP devices have their Frame Counters initialized to 0 at fabrication. In ABP devices the frame counters MUST NEVER be reset during the device’s life time. If the end-device is susceptible of losing power during its life time (battery replacement for example), the frame counters SHALL persist during such event.

Subsequently FCntUp is incremented with each uplink. NFCntDown is incremented with each downlink on FPort 0 or when the FPort field is missing. AFCntDown is incremented with each downlink on a port different than 0. At the receiver side, the corresponding counter is kept in sync with the value received provided the value received has been incremented compared to the current counter value and the message MIC field matches the MIC value computed locally using the appropriate network session key . The FCnt is not incremented in case of multiple transmissions of a confirmed or unconfirmed frame (see NbTrans parameter). The Network Server SHALL drop the application payload of the retransmitted frames and only forward a single instance to the application server.

Frame counters are 32 bits wide, The FCnt field corresponds to the least-significant 16 bits of the 32-bits frame counter (i.e., FCntUp for data frames sent uplink and AFCntDown/NFCntDown for data frames sent downlink).

The end-device SHALL NEVER reuse the same FCntUp value with the same application or network session keys, except for retransmission of the same confirmed or unconfirmed frame.

The end-device SHALL never process any retransmission of the same downlink frame. Subsequent retransmissions SHALL be ignored without being processed.

Note: This means that the device will only acknowledge once the reception of a downlink confirmed frame, similarly the device will only generate a single uplink following the reception of a frame with the FPending bit set.

Note: Since the FCnt field carries only the least-significant 16 bits of the 32-bits frame counter, the server must infer the 16 most-significant bits of the frame counter from the observation of the traffic.

4.3.1.6 Frame options (FOptsLen in FCtrl, FOpts)

The frame-options length field (FOptsLen) in FCtrl byte denotes the actual length of the frame options field (FOpts) included in the frame.

FOpts transport MAC commands of a maximum length of 15 octets that are piggybacked onto data frames; see Chapter 5 for a list of valid MAC commands.

If FOptsLen is 0, the FOpts field is absent. If FOptsLen is different from 0, i.e. if MAC commands are present in the FOpts field, the port 0 cannot be used (FPort must be either not present or different from 0).

MAC commands cannot be simultaneously present in the payload field and the frame options field. Should this occur, the device SHALL ignore the frame.


If a frame header carries FOpts, FOpts MUST be encrypted before the message integrity code (MIC) is calculated.

The encryption scheme used is based on the generic algorithm described in IEEE 802.15.4/2006 Annex B [IEEE802154] using AES with a key length of 128 bits.

The key K used is the NwkSEncKey for FOpts field in both the uplink and downlink direction.

The fields encrypted are: pld = FOpts

For each message, the algorithm defines a single Block A:

The direction field (Dir) is 0 for uplink frames and 1 for downlink frames.

The block A is encrypted to get a block S:

S = aes128_encrypt(K, A)

Encryption and decryption of the FOpts is done by truncating (pld | pad16) xor S to the first len(pld) octets.


4.3.1.7 Class B

The Class B bit set to 1 in an uplink signals the Network Server that the device as switched to Class B mode and is now ready to receive scheduled downlink pings. Please refer to the Class B section of the document for the Class B specification.

4.3.2 Port field (FPort)

If the frame payload field is not empty, the port field MUST be present. If present, an FPort value of 0 indicates that the FRMPayload contains MAC commands only and any received frames with such an FPort shall be processed by the LoRaWAN implementation; see Chapter 5 for a list of valid MAC commands. FPort values 1..223 (0x01..0xDF) are application-specific and any received frames with such an FPort SHALL be made available to the application layer by the LoRaWAN implementation. FPort value 224 is dedicated to LoRaWAN MAC layer test protocol. LoRaWAN implementation SHALL discard any transmission request from the application layer where the FPort value is not in the 1..224 range.

Note: The purpose of FPort value 224 is to provide a dedicated FPort to run MAC compliance test scenarios over-the-air on final versions of devices, without having to rely on specific test versions of devices for practical aspects. The test is not supposed to be simultaneous with live operations, but the MAC layer implementation of the device shall be exactly the one used for the normal application. The test protocol is normally encrypted using the AppSKey. This ensures that the Network Server cannot enable the device’s test mode without involving the device’s owner. If the test runs on a live network connected device, the way the test application on the network side learns the AppSKey is outside of the scope of the LoRaWAN specification. If the test runs using OTAA on a dedicated test bench (not a live network), the way the AppKey is communicated to the test bench, for secured JOIN process, is also outside of the scope of the specification.

The test protocol, running at application layer, is defined outside of the LoRaWAN spec, as it is an application layer protocol.

FPort values 225..255 (0xE1..0xFF) are reserved for future standardized application extensions.

N is the number of octets of the application payload. The valid range for N is region specific and is defined in [PHY].
N MUST be equal or smaller than:

N = M - 1 - (length of FHDR in octets)

where M is the maximum MAC payload length.

4.3.3 MAC Frame Payload Encryption (FRMPayload)

If a data frame carries a payload, FRMPayload MUST be encrypted before the message integrity code (MIC) is calculated.

The encryption scheme used is based on the generic algorithm described in IEEE 802.15.4/2006 Annex B [IEEE802154] using AES with a key length of 128 bits.

The key K used depends on the FPort of the data message:

The fields encrypted are:

pld = FRMPayload

For each data message, the algorithm defines a sequence of Blocks Ai for i = 1..k with k = ceil(len(pld) / 16):

Encryption and decryption of the payload is done by truncating
(pld | pad16) xor S
to the first len(pld) octets.


4.4 Message Integrity Code (MIC)
The message integrity code (MIC) is calculated over all the fields in the message.
msg = MHDR | FHDR | FPort | FRMPayload
whereby len(msg) denotes the length of the message in octets.
4.4.1 Downlink frames
The MIC of a downlink frame is calculated as follows [RFC4493]:
cmac = aes128_cmac(SNwkSIntKey, B0 | msg)
MIC = cmac[0..3]

If the device is connected to a LoRaWAN1.1 Network Server and the ACK bit of the downlink frame is set, meaning this frame is acknowledging an uplink “confirmed” frame, then ConfFCnt is the frame counter value modulo 2^16 of the “confirmed” uplink frame that is being acknowledged. In all other cases ConfFCnt = 0x0000.

Where:

? TxDr is the data rate used for the transmission of the uplink

? TxCh is the index of the channel used for the transmission.

? If the ACK bit of the uplink frame is set, meaning this frame is acknowledging a downlink “confirmed” frame, then ConfFCnt is the frame counter value modulo 2^16 of the “confirmed” downlink frame that is being acknowledged. In all other cases ConfFCnt = 0x0000.

If the device is connected to a LoRaWAN1.0 Network Server then:
MIC = cmacF[0..3]
